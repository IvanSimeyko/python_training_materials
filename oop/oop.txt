Объектно-ориентированное программирование Python.

Как только используется ключевое слово class, Питон исполняет команду и создаёт объект
(да-да класс это тоже объект). Инструкция:

class Blog(object):
    
    def author_name(self, name = 'Ivan'):
        self.name = name
        return name

создаст в памяти объект с именем Blog. 

x = Blog()   # создание экземпляра (тоже объект) класса

x.author_name()   # вызвать метод класса, вернет 'Ivan'

x.__setattr__('id', 1)   # создать аттрибут id и присвоить ему значение
x.id = 1    # тоже, но более короткая запись

x.id   # получит значение аттрибута counter

В классах и в объектах созданных на базе классов имеется атрибут __dict__,
который является словарем пространства имен:

Blog.__dict__   # {'__doc__': None, '__module__': '__main__',
'author_name': <function __main__.author_name>}

x.__dict__    # {'id': 1}

Каждый экземпляр имеет ссылку на свой наследемый класс: x.__class__
Классы имеют атрибут __bases__, который представляет собой кортеж его суперклассов

Методы класса, которые обычно создаются интсрукцией def, вложенной в тело класса,
могут также создаваться на лету:

def upper_name(self):
   return self.name.upper()

Здесь еще ничего не говорится о классе - это просто функция, которая может вызываться при условию
что объект вызываемый ею имеет атрибут name:

upper_name(x)    # вернет "IVAN"

Однако, если эту функцию присовить атрибуту нашего класса, она станет методом, вызываемым из любого экземпляра.

Blog.upper = upper_name


Общие методы перезагрузки операторов:
Метод | Перезагружает | Вызывается
__init__ | Конструктор | При создании объекта: X = Class()
__del__ | Деструктор | При уничтожении объекта
__add__ | Оператор + | X + Y, X += Y
__or__ | Оператор | (побитовое ИЛИ) | X | Y, X | = Y
__repr__, __str__ | Вывод, преобразование | print X, repr(X), str(X)
__call__ | Вызовы функций | X()
__getattr__ | Обращение к атрибуту | X.undefined
__setattr__ | Присваивание атрибутам | X.any = value
__getitem__ | Доступ к элементу по индексу | X[key], циклы for и другие конструкции итерации, при отсутствии метода __iter__
__setitem__ | Присваивание элементу по индексу | X[key] = value
__len__ | Длина | len(X), проверка истинности
__cmp__ | Сравнение | X == Y, X < Y
__lt__ | Специальное сравнение | X < Y (в ином случае __cmp__)
__eq__ | Специальное сравнение | X == Y (в ином случае __cmp__)
__radd__ | Правосторонний оператор + | Не_экземпляр + X
__iadd__ | Добавление (увеличение) | X += Y (в ином случае __add__)
__iter__ | Итерационный контекст | Циклы for, оператор in, генераторы списков, map и другие