# Замыкание - объект функции, который сохранияет значение в объемлющих областях видимости,
# даже  когда  эти  области могут  прекратить  свое существование.


def maker(n):
    def action(x):
        return x**n
    return action

f = maker(2)    # замыкание значения 2 в переменной  n

print(f(3))    # 9
print(f(4))    # 16

#Выражение lambda - выражение, которое генерирует функцию и сопровождается появлением новой локальной области видимости.


def func():
    x = 4
    action = (lambda n: n**4)
    return action

x = func()
print(x(2))    # 16

# Встроенные фундкции map, zip, filter принимают в качевте аргументом интерируемые объекты
# и возвращают итераторы (в третьей ветке) или

# Функция zip принимает одну или несколько последовательностей в качестве аргуметов и возвращает
# список кортежей, составленных из соответствующих элементов этих кортежей (во второй ветке) или
# итерируемый объект (в третьей ветке)
c = zip((1,2), (3,4))
print(next(c))   # (1, 3)

# Функция map принимает функцию и одну или более последовательностей и собирает результаты вызова
# функции с соответствующиеми элементами, извлеченными из последоавтельностей. В ветке 2 на выходе имеем
# список, в ветке 3 - итерируемый объект

m = map(ord, 'spam')
print(next(m))    # 115

#Функция filter - позволяет фильтровать значения последовательности.
# В результирующем списке только те значения, для которых значение функции для
# элемента истинно.

numbers = [10, 4, 2, -1, 6]
f = filter(lambda x: x < 5, numbers)
print(next(f))    # 4 в 3 ветке или [4, 2, -1] во второй

# Функция reduce (python 2) - используется для организации цепочечных вычислений в списке. Она принимает
# итератор, но возвращает одиночный объект

numbers = [2, 3, 4, 5, 6]
reduce(lambda res, x: res*x, numbers, 1)    #720

#Вычисления происходят в следующем порядке: ((((1*2)*3)*4)*5)*6.
#Цепочка вызовов связывается с помощью промежуточного результата (res). Если список пустой, просто используется третий
# параметр (в случае произведения нуля множителей это 1)
